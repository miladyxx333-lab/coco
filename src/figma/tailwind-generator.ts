/**
 * TAILWIND CODE GENERATOR
 * Generates Tailwind CSS code from wireframe JSON (Mirror Generation)
 */

import type { WireframeDocument, WireframeNode } from './wireframe-schema.js';

// ============================================
// TAILWIND MAPPING
// ============================================

function hexToTailwindColor(hex: string): string {
    // Map common colors to Tailwind classes
    const colorMap: Record<string, string> = {
        '#3B82F6': 'blue-500',
        '#6366F1': 'indigo-500',
        '#8B5CF6': 'violet-500',
        '#EC4899': 'pink-500',
        '#EF4444': 'red-500',
        '#F97316': 'orange-500',
        '#EAB308': 'yellow-500',
        '#22C55E': 'green-500',
        '#14B8A6': 'teal-500',
        '#06B6D4': 'cyan-500',
        '#FFFFFF': 'white',
        '#000000': 'black',
        '#111827': 'gray-900',
        '#1F2937': 'gray-800',
        '#374151': 'gray-700',
        '#4B5563': 'gray-600',
        '#6B7280': 'gray-500',
        '#9CA3AF': 'gray-400',
        '#D1D5DB': 'gray-300',
        '#E5E7EB': 'gray-200',
        '#F3F4F6': 'gray-100',
        '#F9FAFB': 'gray-50',
    };

    return colorMap[hex.toUpperCase()] || `[${hex}]`;
}

function pxToTailwind(px: number): string {
    const mapping: Record<number, string> = {
        0: '0',
        4: '1',
        8: '2',
        12: '3',
        16: '4',
        20: '5',
        24: '6',
        28: '7',
        32: '8',
        36: '9',
        40: '10',
        44: '11',
        48: '12',
        56: '14',
        64: '16',
        80: '20',
        96: '24',
        112: '28',
        128: '32',
    };

    return mapping[px] || `[${px}px]`;
}

function fontSizeToTailwind(size: number): string {
    const mapping: Record<number, string> = {
        12: 'text-xs',
        14: 'text-sm',
        16: 'text-base',
        18: 'text-lg',
        20: 'text-xl',
        24: 'text-2xl',
        28: 'text-3xl',
        32: 'text-4xl',
        36: 'text-4xl',
        40: 'text-5xl',
        48: 'text-5xl',
        56: 'text-6xl',
        64: 'text-7xl',
    };

    return mapping[size] || `text-[${size}px]`;
}

function fontWeightToTailwind(weight: string): string {
    const mapping: Record<string, string> = {
        'regular': 'font-normal',
        'medium': 'font-medium',
        'semibold': 'font-semibold',
        'bold': 'font-bold',
    };

    return mapping[weight] || 'font-normal';
}

function cornerRadiusToTailwind(radius: number): string {
    const mapping: Record<number, string> = {
        0: 'rounded-none',
        4: 'rounded',
        8: 'rounded-lg',
        12: 'rounded-xl',
        16: 'rounded-2xl',
        24: 'rounded-3xl',
        9999: 'rounded-full',
    };

    return mapping[radius] || `rounded-[${radius}px]`;
}

// ============================================
// CODE GENERATOR CLASS
// ============================================

export class TailwindGenerator {
    private indent = 0;

    /**
     * Generate complete React + Tailwind component from wireframe
     */
    generateReactComponent(wireframe: WireframeDocument): string {
        const componentName = this.toPascalCase(wireframe.document.name);
        const pages = wireframe.document.pages.map(page => this.generatePage(page));

        return `
import React from 'react';

/**
 * ${wireframe.document.name}
 * ${wireframe.document.description || 'Auto-generated wireframe component'}
 * Generated by: Gemini Product Brain
 * Timestamp: ${wireframe.$metadata.timestamp}
 */

${pages.join('\n\n')}

export default function ${componentName}() {
  return (
    <div className="min-h-screen bg-white">
      <${componentName}Desktop />
    </div>
  );
}
`.trim();
    }

    private generatePage(page: import('./wireframe-schema.js').WireframePage): string {
        const componentName = `${this.toPascalCase(page.name)}`;
        const children = page.nodes.map(node => this.generateNode(node, 2));

        return `
function ${componentName}() {
  return (
    <div className="w-full max-w-[${page.viewport.width}px] mx-auto bg-${hexToTailwindColor(page.backgroundColor)}">
${children.join('\n')}
    </div>
  );
}
`.trim();
    }

    private generateNode(node: WireframeNode, indentLevel: number): string {
        const indent = '  '.repeat(indentLevel);
        const classes = this.buildClasses(node);
        const tag = this.getTag(node);
        const hasChildren = node.children && node.children.length > 0;
        const hasText = node.text && node.type !== 'button';

        if (node.type === 'button') {
            return `${indent}<button className="${classes}">${node.text || 'Button'}</button>`;
        }

        if (node.type === 'text') {
            const textTag = this.getTextTag(node);
            return `${indent}<${textTag} className="${classes}">${node.text || ''}</${textTag}>`;
        }

        if (node.type === 'input') {
            return this.generateInput(node, indent);
        }

        if (!hasChildren && !hasText) {
            if (node.type === 'image-placeholder') {
                return `${indent}<div className="${classes}">\n${indent}  {/* Image placeholder */}\n${indent}</div>`;
            }
            return `${indent}<${tag} className="${classes}" />`;
        }

        let childrenCode = '';
        if (hasChildren) {
            childrenCode = node.children!.map((child: WireframeNode) => this.generateNode(child, indentLevel + 1)).join('\n');
        }
        if (hasText) {
            childrenCode = `${'  '.repeat(indentLevel + 1)}${node.text}`;
        }

        return `${indent}<${tag} className="${classes}">\n${childrenCode}\n${indent}</${tag}>`;
    }

    private generateInput(node: WireframeNode, indent: string): string {
        const labelChild = node.children?.find((c: WireframeNode) => c.name.toLowerCase().includes('label'));
        const inputChild = node.children?.find((c: WireframeNode) => c.name.toLowerCase().includes('field'));

        return `
${indent}<div className="flex flex-col gap-2">
${indent}  <label className="text-sm font-medium text-gray-700">${labelChild?.text || 'Label'}</label>
${indent}  <input 
${indent}    type="text" 
${indent}    className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
${indent}    placeholder="Enter value..."
${indent}  />
${indent}</div>
`.trimEnd();
    }

    private buildClasses(node: WireframeNode): string {
        const classes: string[] = [];

        // Dimensions
        if (node.dimensions.width === 1440 || node.dimensions.width === 1200) {
            classes.push('w-full');
        } else {
            classes.push(`w-[${node.dimensions.width}px]`);
        }

        if (node.dimensions.height) {
            classes.push(`h-[${node.dimensions.height}px]`);
        }

        // Background
        if (node.fill) {
            classes.push(`bg-${hexToTailwindColor(node.fill)}`);
        }

        // Border
        if (node.stroke) {
            classes.push('border');
            classes.push(`border-${hexToTailwindColor(node.stroke)}`);
        }

        // Border radius
        if (node.cornerRadius) {
            const radius = typeof node.cornerRadius === 'number' ? node.cornerRadius : 8;
            classes.push(cornerRadiusToTailwind(radius));
        }

        // Layout
        if (node.layoutMode === 'horizontal') {
            classes.push('flex flex-row items-center');
        } else if (node.layoutMode === 'vertical') {
            classes.push('flex flex-col');
        }

        // Padding
        if (node.padding) {
            classes.push(`p-${pxToTailwind(node.padding)}`);
        }

        // Gap
        if (node.gap) {
            classes.push(`gap-${pxToTailwind(node.gap)}`);
        }

        // Text styling
        if (node.fontSize) {
            classes.push(fontSizeToTailwind(node.fontSize));
        }

        if (node.fontWeight) {
            classes.push(fontWeightToTailwind(node.fontWeight));
        }

        if (node.textAlign === 'center') {
            classes.push('text-center');
        } else if (node.textAlign === 'right') {
            classes.push('text-right');
        }

        if (node.textColor) {
            classes.push(`text-${hexToTailwindColor(node.textColor)}`);
        }

        // Button specific
        if (node.type === 'button') {
            classes.push('inline-flex items-center justify-center');
            classes.push('transition-colors duration-200');
            classes.push('hover:opacity-90');
            classes.push('focus:outline-none focus:ring-2 focus:ring-offset-2');
        }

        return classes.join(' ');
    }

    private getTag(node: WireframeNode): string {
        const tagMap: Record<string, string> = {
            'navbar': 'nav',
            'hero': 'section',
            'section': 'section',
            'footer': 'footer',
            'card': 'article',
            'frame': 'div',
            'rectangle': 'div',
            'grid': 'div',
        };

        return tagMap[node.type] || 'div';
    }

    private getTextTag(node: WireframeNode): string {
        if (!node.fontSize) return 'p';

        if (node.fontSize >= 48) return 'h1';
        if (node.fontSize >= 36) return 'h2';
        if (node.fontSize >= 28) return 'h3';
        if (node.fontSize >= 20) return 'h4';
        if (node.fontSize >= 16) return 'p';
        return 'span';
    }

    private toPascalCase(str: string): string {
        return str
            .replace(/[^a-zA-Z0-9 ]/g, '')
            .split(' ')
            .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
            .join('');
    }

    /**
     * Generate CSS custom properties from design tokens
     */
    generateCSSVariables(wireframe: WireframeDocument): string {
        if (!wireframe.designTokens) {
            return '/* No design tokens defined */';
        }

        const tokens = wireframe.designTokens;
        let css = ':root {\n';

        // Colors
        if (tokens.colors) {
            css += '  /* Colors */\n';
            for (const [name, value] of Object.entries(tokens.colors)) {
                css += `  --color-${name}: ${value};\n`;
            }
        }

        // Spacing
        if (tokens.spacing) {
            css += '\n  /* Spacing */\n';
            for (const [name, value] of Object.entries(tokens.spacing)) {
                css += `  --spacing-${name}: ${value}px;\n`;
            }
        }

        // Typography
        if (tokens.typography) {
            css += '\n  /* Typography */\n';
            for (const [name, value] of Object.entries(tokens.typography)) {
                css += `  --font-size-${name}: ${value.fontSize}px;\n`;
            }
        }

        css += '}\n';

        return css;
    }
}

// ============================================
// FACTORY
// ============================================

export const tailwindGenerator = new TailwindGenerator();
